(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{464:function(t,a,s){"use strict";s.r(a);var r=s(2),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"更多知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更多知识"}},[t._v("#")]),t._v(" 更多知识")]),t._v(" "),a("p",[t._v("该部分知识的特点：")]),t._v(" "),a("ul",[a("li",[t._v("面试有较低的机率被问到")]),t._v(" "),a("li",[t._v("实际编码中用得不是太多")])]),t._v(" "),a("h2",{attrs:{id:"_1-符号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-符号"}},[t._v("#")]),t._v(" "),a("strong",[t._v("1. 符号")])]),t._v(" "),a("p",[t._v("作用：消除魔法字符、避免一个复杂对象中含有多个属性的时候某个属性名覆盖掉、模拟类的私有方法")]),t._v(" "),a("h3",{attrs:{id:"普通符号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#普通符号"}},[t._v("#")]),t._v(" 普通符号")]),t._v(" "),a("p",[t._v("符号是ES6新增的一个数据类型，它通过使用函数 "),a("code",[t._v("Symbol(符号描述)")]),t._v(" 来创建")]),t._v(" "),a("p",[t._v("符号设计的初衷，是为了给对象设置私有属性")]),t._v(" "),a("p",[t._v("私有属性：只能在对象内部使用，外面无法使用")]),t._v(" "),a("p",[t._v("符号具有以下特点：")]),t._v(" "),a("ul",[a("li",[t._v("没有字面量")]),t._v(" "),a("li",[t._v("使用 typeof 得到的类型是 symbol")]),t._v(" "),a("li",[a("strong",[t._v("每次调用 Symbol 函数得到的符号永远不相等，无论符号名是否相同")])]),t._v(" "),a("li",[t._v("符号可以作为对象的属性名存在，这种属性称之为符号属性\n"),a("ul",[a("li",[t._v("开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问")]),t._v(" "),a("li",[t._v("符号属性是不能枚举的，因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性")]),t._v(" "),a("li",[t._v("Object.getOwnPropertyNames 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性")]),t._v(" "),a("li",[t._v("ES6 新增 Object.getOwnPropertySymbols 方法，可以读取符号")])])]),t._v(" "),a("li",[t._v("符号无法被隐式转换，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但符号可以显式的转换为字符串，通过 String 构造函数进行转换即可，console.log 之所以可以输出符号，是它在内部进行了显式转换")])]),t._v(" "),a("h3",{attrs:{id:"共享符号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#共享符号"}},[t._v("#")]),t._v(" 共享符号")]),t._v(" "),a("p",[t._v("根据某个符号名称（符号描述）能够得到同一个符号")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("Symbol"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"符号名/符号描述"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//获取共享符号")]),t._v("\n")])])]),a("h3",{attrs:{id:"知名符号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#知名符号"}},[t._v("#")]),t._v(" 知名符号")]),t._v(" "),a("p",[t._v("知名符号是一些具有特殊含义的共享符号，通过 Symbol 的静态属性得到")]),t._v(" "),a("p",[t._v("ES6 延续了 ES5 的思想：减少魔法，暴露内部实现！")]),t._v(" "),a("p",[t._v("因此，ES6 用知名符号暴露了某些场景的内部实现")]),t._v(" "),a("ol",[a("li",[t._v("Symbol.hasInstance")])]),t._v(" "),a("p",[t._v("该符号用于定义构造函数的静态成员，它将影响 instanceof 的判定")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("\nobj "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//等效于")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Symbol"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hasInstance"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Function.prototype[Symbol.hasInstance]")]),t._v("\n\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("[扩展] Symbol.isConcatSpreadable")])]),t._v(" "),a("p",[t._v("该知名符号会影响数组的 concat 方法")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("[扩展] Symbol.toPrimitive")])]),t._v(" "),a("p",[t._v("该知名符号会影响类型转换的结果")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("[扩展] Symbol.toStringTag")])]),t._v(" "),a("p",[t._v("该知名符号会影响 Object.prototype.toString 的返回值")]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("其他知名符号")])]),t._v(" "),a("h2",{attrs:{id:"_2-迭代器和生成器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-迭代器和生成器"}},[t._v("#")]),t._v(" "),a("strong",[t._v("2.  迭代器和生成器")])]),t._v(" "),a("p",[t._v("作用：实现异步的一种方式，React 中大量使用到了生成器，Koa第一代也是大量用到了生成器。")]),t._v(" "),a("h3",{attrs:{id:"迭代器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[t._v("#")]),t._v(" "),a("strong",[t._v("迭代器")])]),t._v(" "),a("ol",[a("li",[t._v("什么是迭代？")])]),t._v(" "),a("p",[t._v("从一个数据集合中按照一定的顺序，不断取出数据的过程")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("迭代和遍历的区别？")])]),t._v(" "),a("p",[t._v("迭代强调的是依次取数据，并不保证取多少，也不保证把所有的数据取完")]),t._v(" "),a("p",[t._v("遍历强调的是要把整个数据依次全部取出")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("迭代器")])]),t._v(" "),a("p",[t._v("对迭代过程的封装，在不同的语言中有不同的表现形式，通常为对象")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("迭代模式")])]),t._v(" "),a("p",[t._v("一种设计模式，用于统一迭代过程，并规范了迭代器规格：")]),t._v(" "),a("ul",[a("li",[t._v("迭代器应该具有得到下一个数据的能力")]),t._v(" "),a("li",[t._v("迭代器应该具有判断是否还有后续数据的能力")])]),t._v(" "),a("h3",{attrs:{id:"js中的迭代器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js中的迭代器"}},[t._v("#")]),t._v(" JS中的迭代器")]),t._v(" "),a("p",[t._v("JS规定，如果一个对象具有next方法，并且该方法返回一个对象，该对象的格式如下：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("value")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 值"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("done")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" 是否迭代完成"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("则认为该对象是一个迭代器")]),t._v(" "),a("p",[t._v("含义：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("next方法：用于得到下一个数据")])]),t._v(" "),a("li",[a("p",[t._v("返回的对象")]),t._v(" "),a("ul",[a("li",[t._v("value：下一个数据的值")]),t._v(" "),a("li",[t._v("done：boolean，是否迭代完成")])]),t._v(" "),a("h4",{attrs:{id:"可迭代协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可迭代协议"}},[t._v("#")]),t._v(" "),a("strong",[t._v("可迭代协议")])]),t._v(" "),a("p",[t._v("ES6规定，如果一个对象具有知名符号属性"),a("code",[t._v("Symbol.iterator")]),t._v("，并且属性值是一个迭代器创建函数，则该对象是可迭代的（iterable）")]),t._v(" "),a("blockquote",[a("p",[t._v("思考：如何知晓一个对象是否是可迭代的？\n思考：如何遍历一个可迭代对象？")])]),t._v(" "),a("h4",{attrs:{id:"for-of-循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-of-循环"}},[t._v("#")]),t._v(" for-of 循环")]),t._v(" "),a("p",[t._v("for-of 循环用于遍历可迭代对象，格式如下")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//迭代完成后循环结束")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" item "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("of")]),t._v(" iterable"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//iterable：可迭代对象")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//item：每次迭代得到的数据")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h4",{attrs:{id:"展开运算符与可迭代对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#展开运算符与可迭代对象"}},[t._v("#")]),t._v(" 展开运算符与可迭代对象")]),t._v(" "),a("p",[t._v("展开运算符可以作用于可迭代对象，这样，就可以轻松的将可迭代对象转换为数组。")]),t._v(" "),a("h3",{attrs:{id:"生成器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成器"}},[t._v("#")]),t._v(" 生成器")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("什么是生成器？")])])]),t._v(" "),a("p",[t._v("生成器是一个通过构造函数Generator创建的对象，生成器既是一个迭代器，同时又是一个可迭代对象")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("如何创建生成器？")])])]),t._v(" "),a("p",[t._v("生成器的创建，必须使用生成器函数（Generator Function）")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[t._v("如何书写一个生成器函数呢？")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这是一个生成器函数，该函数一定返回一个生成器")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("ol",{attrs:{start:"4"}},[a("li",[a("strong",[t._v("生成器函数内部是如何执行的？")])])]),t._v(" "),a("p",[t._v("生成器函数内部是为了给生成器的每次迭代提供的数据")]),t._v(" "),a("p",[t._v("每次调用生成器的next方法，将导致生成器函数运行到下一个yield关键字位置")]),t._v(" "),a("p",[t._v("yield是一个关键字，该关键字只能在生成器函数内部使用，表达“产生”一个迭代数据。")]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[a("strong",[t._v("有哪些需要注意的细节？")])])]),t._v(" "),a("p",[t._v("1). 生成器函数可以有返回值，返回值出现在第一次done为true时的value属性中\n2). 调用生成器的next方法时，可以传递参数，传递的参数会交给yield表达式的返回值\n3). 第一次调用next方法时，传参没有任何意义\n4). 在生成器函数内部，可以调用其他生成器函数，但是要注意加上*号")]),t._v(" "),a("ol",{attrs:{start:"6"}},[a("li",[a("strong",[t._v("生成器的其他API")])])]),t._v(" "),a("ul",[a("li",[t._v("return方法：调用该方法，可以提前结束生成器函数，从而提前让整个迭代过程结束")]),t._v(" "),a("li",[t._v("throw方法：调用该方法，可以在生成器中产生一个错误")])])])]),t._v(" "),a("h2",{attrs:{id:"_3-代理与反射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-代理与反射"}},[t._v("#")]),t._v(" "),a("strong",[t._v("3. 代理与反射")])]),t._v(" "),a("p",[t._v("作用：属于元编程的知识，写框架的时候会用到")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("### Reflect\n")])])]),a("ol",[a("li",[a("strong",[t._v("Reflect是什么？")])])]),t._v(" "),a("p",[t._v("Reflect是一个内置的JS对象，它提供了一系列方法，可以让开发者通过调用这些方法，访问一些JS底层功能")]),t._v(" "),a("p",[t._v("由于它类似于其他语言的"),a("strong",[t._v("反射")]),t._v("，因此取名为Reflect")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("它可以做什么？")])])]),t._v(" "),a("p",[t._v("使用Reflect可以实现诸如 属性的赋值与取值、调用普通函数、调用构造函数、判断属性是否存在与对象中  等等功能")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("strong",[t._v("这些功能不是已经存在了吗？为什么还需要用Reflect实现一次？")])])]),t._v(" "),a("p",[t._v("有一个重要的理念，在ES5就被提出：减少魔法、让代码更加纯粹")]),t._v(" "),a("p",[t._v("这种理念很大程度上是受到函数式编程的影响")]),t._v(" "),a("p",[t._v("ES6进一步贯彻了这种理念，它认为，对属性内存的控制、原型链的修改、函数的调用等等，这些都属于底层实现，属于一种魔法，因此，需要将它们提取出来，形成一个正常的API，并高度聚合到某个对象中，于是，就造就了Reflect对象")]),t._v(" "),a("p",[t._v("因此，你可以看到Reflect对象中有很多的API都可以使用过去的某种语法或其他API实现。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[a("strong",[t._v("它里面到底提供了哪些API呢？")])])]),t._v(" "),a("ul",[a("li",[t._v("Reflect.set(target, propertyKey, value): 设置对象target的属性propertyKey的值为value，等同于给对象的属性赋值")]),t._v(" "),a("li",[t._v("Reflect.get(target, propertyKey): 读取对象target的属性propertyKey，等同于读取对象的属性值")]),t._v(" "),a("li",[t._v("Reflect.apply(target, thisArgument, argumentsList)：调用一个指定的函数，并绑定this和参数列表。等同于函数调用")]),t._v(" "),a("li",[t._v("Reflect.deleteProperty(target, propertyKey)：删除一个对象的属性")]),t._v(" "),a("li",[t._v("Reflect.defineProperty(target, propertyKey, attributes)：类似于Object.defineProperty，不同的是如果配置出现问题，返回false而不是报错")]),t._v(" "),a("li",[t._v("Reflect.construct(target, argumentsList)：用构造函数的方式创建一个对象")]),t._v(" "),a("li",[t._v("Reflect.has(target, propertyKey): 判断一个对象是否拥有一个属性")]),t._v(" "),a("li",[t._v("其他API：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect")])]),t._v(" "),a("h3",{attrs:{id:"proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[t._v("#")]),t._v(" Proxy")]),t._v(" "),a("p",[t._v("代理：提供了修改底层实现的方式")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//代理一个目标对象")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//target：目标对象")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//handler：是一个普通对象，其中可以重写底层实现")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//返回一个代理对象")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Proxy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" handler"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h2",{attrs:{id:"_4-增强的数组功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-增强的数组功能"}},[t._v("#")]),t._v(" "),a("strong",[t._v("4. 增强的数组功能")])]),t._v(" "),a("p",[t._v("作用：JavaScript 类型化数组是一种类似数组的对象，并提供了一种用于访问原始二进制数据的机制。JavaScript引擎会做一些内部优化，以便对数组的操作可以很快。")]),t._v(" "),a("p",[a("strong",[t._v("静态方法")])]),t._v(" "),a("ul",[a("li",[t._v("Array.of(...args): 使用指定的数组项创建一个新数组")]),t._v(" "),a("li",[t._v("Array.from(arg): 通过给定的类数组 或 可迭代对象 创建一个新的数组。")])]),t._v(" "),a("p",[a("strong",[t._v("实例方法")])]),t._v(" "),a("ul",[a("li",[t._v("find(callback): 用于查找满足条件的第一个元素")]),t._v(" "),a("li",[t._v("findIndex(callback)：用于查找满足条件的第一个元素的下标")]),t._v(" "),a("li",[t._v("fill(data)：用指定的数据填充满数组所有的内容")]),t._v(" "),a("li",[t._v("copyWithin(target, start?, end?): 在数组内部完成复制")]),t._v(" "),a("li",[t._v("includes(data)：判断数组中是否包含某个值，使用Object.is匹配")])]),t._v(" "),a("h3",{attrs:{id:"类型化数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型化数组"}},[t._v("#")]),t._v(" "),a("strong",[t._v("类型化数组")])]),t._v(" "),a("h4",{attrs:{id:"数组存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组存储"}},[t._v("#")]),t._v(" 数组存储")]),t._v(" "),a("ol",[a("li",[t._v("计算机必须使用固定的位数来存储数字，无论存储的数字是大是小，在内存中占用的空间是固定的。")]),t._v(" "),a("li",[t._v("n位的无符号整数能表示的数字是2^n个，取值范围是：0 ~ 2^n - 1")]),t._v(" "),a("li",[t._v("n位的有符号整数能表示的数字是2^n个，取值范围是：-2^(n-1) ~ 2^(n-1) - 1")]),t._v(" "),a("li",[t._v("浮点数表示法可以用于表示整数和小数，目前分为两种标准：\n"),a("ol",[a("li",[t._v("32位浮点数：又称为单精度浮点数，它用1位表示符号，8位表示阶码，23位表示尾数")]),t._v(" "),a("li",[t._v("64位浮点数：又称为双精度浮点数，它用1位表示符号，11位表示阶码，52位表示尾数")])])]),t._v(" "),a("li",[t._v("JS中的所有数字，均使用双精度浮点数保存")])]),t._v(" "),a("h4",{attrs:{id:"类型化数组-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型化数组-2"}},[t._v("#")]),t._v(" "),a("strong",[t._v("类型化数组")])]),t._v(" "),a("p",[t._v("类型化数组：用于优化多个数字的存储")]),t._v(" "),a("p",[t._v("具体分为：")]),t._v(" "),a("ul",[a("li",[t._v("Int8Array： 8位有符号整数（-128 ~ 127）")]),t._v(" "),a("li",[t._v("Uint8Array： 8位无符号整数（0 ~ 255）")]),t._v(" "),a("li",[t._v("Int16Array: ...")]),t._v(" "),a("li",[t._v("Uint16Array: ...")]),t._v(" "),a("li",[t._v("Int32Array: ...")]),t._v(" "),a("li",[t._v("Uint32Array:  ...")]),t._v(" "),a("li",[t._v("Float32Array: ...")]),t._v(" "),a("li",[t._v("Float64Array: ...")])]),t._v(" "),a("ol",[a("li",[t._v("如何创建数组")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("数组构造函数")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("长度"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n数组构造函数"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("of")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("元素"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n数组构造函数"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("from")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("可迭代对象"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("数组构造函数")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("其他类型化数组"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("得到长度")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("数组"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//得到元素数量")]),t._v("\n数组"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("byteLength "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//得到占用的字节数")]),t._v("\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("其他的用法跟普通数组一致，但是：")])]),t._v(" "),a("ul",[a("li",[t._v("不能增加和删除数据，类型化数组的长度固定")]),t._v(" "),a("li",[t._v("一些返回数组的方法，返回的数组是同类型化的新数组")])]),t._v(" "),a("h2",{attrs:{id:"arraybuffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arraybuffer"}},[t._v("#")]),t._v(" ArrayBuffer")]),t._v(" "),a("p",[t._v("ArrayBuffer：一个对象，用于存储一块固定内存大小的数据。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayBuffer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("字节数"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),a("p",[t._v("可以通过属性"),a("code",[t._v("byteLength")]),t._v("得到字节数，可以通过方法"),a("code",[t._v("slice")]),t._v("得到新的ArrayBuffer")]),t._v(" "),a("h3",{attrs:{id:"读写arraybuffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读写arraybuffer"}},[t._v("#")]),t._v(" 读写ArrayBuffer")]),t._v(" "),a("ol",[a("li",[t._v("使用DataView")])]),t._v(" "),a("p",[t._v("通常会在需要混用多种存储格式时使用DataView")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("使用类型化数组")])]),t._v(" "),a("p",[t._v("实际上，每一个类型化数组都对应一个ArrayBuffer，如果没有手动指定ArrayBuffer，类型化数组创建时，会新建一个ArrayBuffer")])])}),[],!1,null,null,null);a.default=e.exports}}]);